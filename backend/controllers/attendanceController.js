const crypto = require('crypto');
const SessionNew = require('../models/SessionNew');
const AttendanceNew = require('../models/AttendanceNew');
const Teaching = require('../models/Teaching');
const Subject = require('../models/Subject'); // Required for populate to work
const QRToken = require('../models/QRToken');
const Student = require('../models/Student');
const AuditLog = require('../models/AuditLog');

/**
 * @desc    Create attendance session
 * @route   POST /api/attendance/create
 * @access  Teacher only
 *
 * Flow:
 * 1. Validate input (teaching_id, startTime, endTime)
 * 2. Verify Teaching assignment exists and is active
 * 3. Verify faculty owns this Teaching
 * 4. Check for overlapping ACTIVE sessions
 * 5. Create SessionNew with secret_key
 * 6. Generate first QRToken
 * 7. Audit-log session creation
 * 8. Return session (with secret_key for QR generation)
 */
const createSession = async (req, res) => {
  try {
    const { teaching_id, startTime, endTime } = req.body;

    // --- INPUT VALIDATION ---
    if (!teaching_id || !startTime || !endTime) {
      return res.status(400).json({ message: 'Please provide teaching_id, startTime, and endTime.' });
    }

    // Validate time window
    const start = new Date(startTime);
    const end = new Date(endTime);

    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      return res.status(400).json({ message: 'Invalid date format for startTime or endTime.' });
    }

    if (start >= end) {
      return res.status(400).json({ message: 'End time must be after start time.' });
    }
    // ------------------------

    // 1. Verify Teaching exists and is active
    const teaching = await Teaching.findById(teaching_id).populate('subject_id');
    if (!teaching) {
      return res.status(404).json({ message: 'Teaching assignment not found.' });
    }

    if (!teaching.is_active) {
      return res.status(400).json({ message: 'Teaching assignment is inactive.' });
    }

    // 2. Verify faculty owns this Teaching
    if (teaching.faculty_id.toString() !== req.user._id.toString()) {
      await AuditLog.log({
        action: 'UNAUTHORIZED_ACCESS',
        actor_type: 'faculty',
        actor_id: req.user._id,
        target_type: 'session',
        metadata: {
          teaching_id,
          reason: 'faculty_not_assigned',
          actual_faculty: teaching.faculty_id.toString()
        }
      });
      return res.status(403).json({ message: 'You are not assigned to teach this course.' });
    }

    // 3. Check for overlapping ACTIVE sessions (same teaching, overlapping time)
    const overlapping = await SessionNew.findOne({
      teaching_id,
      status: { $in: ['scheduled', 'active'] },
      $or: [
        { start_time: { $lt: end }, end_time: { $gt: start } }
      ]
    });

    if (overlapping) {
      return res.status(400).json({
        message: 'An active or scheduled session already exists for this time window.',
        existing_session: overlapping._id
      });
    }

    // 4. Create session (secret_key auto-generated by schema)
    const session = await SessionNew.create({
      teaching_id,
      start_time: start,
      end_time: end,
      status: 'scheduled'
    });

    // Auto-update status based on current time
    session.updateStatusByTime();
    await session.save();

    // 5. Generate first QR token (60s validity)
    const qrToken = await QRToken.generateForSession(session._id, 60000);

    // 6. Audit log session creation
    await AuditLog.logSessionCreate(req.user._id, session._id, {
      teaching_id,
      subject: teaching.subject_id?.name || 'Unknown',
      section: teaching.section,
      semester: teaching.semester
    });

    // Return session with secret_key and first token
    res.status(201).json({
      _id: session._id,
      teaching_id: session.teaching_id,
      start_time: session.start_time,
      end_time: session.end_time,
      status: session.status,
      secret_key: session.secret_key, // Returned on creation only
      current_token: qrToken.token,
      token_expires_at: qrToken.expires_at,
      created_at: session.created_at
    });

  } catch (error) {
    console.error('Create session error:', error);
    res.status(500).json({ message: 'Server Error creating session' });
  }
};

/**
 * @desc    Mark attendance
 * @route   POST /api/attendance/mark
 * @access  Student only
 *
 * Flow:
 * 1. Validate input (sessionId, qr_token REQUIRED)
 * 2. Validate QR token (expiry + existence)
 * 3. Fetch session with populated Teaching
 * 4. Validate session is active and within time window
 * 5. Validate student enrollment (section + semester match)
 * 6. Check for duplicate attendance
 * 7. Create AttendanceNew with verification metadata
 * 8. Audit-log success/failure
 */
const markAttendance = async (req, res) => {
  try {
    const { sessionId, qr_token } = req.body;

    // --- INPUT VALIDATION ---
    if (!sessionId) {
      return res.status(400).json({ message: 'Please provide sessionId.' });
    }

    // QR token is REQUIRED for security (replay protection)
    if (!qr_token) {
      return res.status(400).json({ message: 'QR token is required. Please scan a valid QR code.' });
    }
    // ------------------------

    const student = req.user;

    // 1. Validate QR token (MANDATORY)
    const validToken = await QRToken.validateToken(sessionId, qr_token);
    if (!validToken) {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'invalid_or_expired_token',
        qr_token,
        ip: req.ip
      });
      return res.status(400).json({ message: 'Invalid or expired QR token. Please scan again.' });
    }

    // 2. Fetch session with populated Teaching
    const session = await SessionNew.findById(sessionId).populate({
      path: 'teaching_id',
      populate: { path: 'subject_id' }
    });

    if (!session) {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'session_not_found',
        ip: req.ip
      });
      return res.status(404).json({ message: 'Session not found' });
    }

    // Auto-update session status based on time
    session.updateStatusByTime();
    await session.save();

    // 3. Validate session is active
    if (session.status === 'cancelled') {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'session_cancelled',
        ip: req.ip
      });
      return res.status(400).json({ message: 'Session has been cancelled.' });
    }

    if (session.status === 'completed') {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'session_completed',
        ip: req.ip
      });
      return res.status(400).json({ message: 'Session has ended. Attendance closed.' });
    }

    // 4. Validate time window
    const now = new Date();
    if (now < session.start_time) {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'before_start_time',
        ip: req.ip
      });
      return res.status(400).json({ message: 'Class has not started yet!' });
    }

    if (now > session.end_time) {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'after_end_time',
        ip: req.ip
      });
      return res.status(400).json({ message: 'Class has ended! Attendance closed.' });
    }

    // 5. Validate student enrollment
    const teaching = session.teaching_id;
    if (!teaching) {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'orphaned_session',
        ip: req.ip
      });
      return res.status(400).json({ message: 'Session has invalid teaching assignment. Please contact your instructor.' });
    }

    if (student.section !== teaching.section || student.semester !== teaching.semester) {
      await AuditLog.logAttendance(student._id, sessionId, false, {
        reason: 'not_enrolled',
        student_section: student.section,
        student_semester: student.semester,
        teaching_section: teaching.section,
        teaching_semester: teaching.semester,
        ip: req.ip
      });
      return res.status(403).json({
        message: 'You are not enrolled in this course.',
        details: 'Your section and semester must match the course.'
      });
    }

    // 6. Check for duplicate attendance (pre-query for better error message)
    const alreadyMarked = await AttendanceNew.hasMarkedAttendance(sessionId, student._id);
    if (alreadyMarked) {
      return res.status(400).json({ message: 'You have already marked attendance!' });
    }

    // 7. Create attendance record with verification metadata
    try {
      await AttendanceNew.markAttendance({
        session_id: sessionId,
        student_id: student._id,
        student_name: student.name,
        student_usn: student.usn,
        qr_token_used: qr_token || null,
        ip_address: req.ip || req.connection?.remoteAddress || null,
        user_agent: req.headers['user-agent'] || null
      });
    } catch (dbError) {
      // Handle duplicate key error (race condition defense)
      if (dbError.code === 11000) {
        return res.status(400).json({ message: 'You have already marked attendance!' });
      }
      throw dbError;
    }

    // 8. Audit log success
    await AuditLog.logAttendance(student._id, sessionId, true, {
      qr_token_used: qr_token || null,
      ip: req.ip
    });

    res.json({ message: 'Attendance Marked Successfully!' });

  } catch (error) {
    console.error('Mark attendance error:', error);
    res.status(500).json({ message: 'Server Error marking attendance' });
  }
};

/**
 * @desc    Get student's attendance history
 * @route   GET /api/attendance/history
 * @access  Student only
 */
const getStudentHistory = async (req, res) => {
  try {
    const historyRaw = await AttendanceNew.find({ student_id: req.user._id })
      .populate({
        path: 'session_id',
        select: 'start_time end_time status teaching_id',
        populate: {
          path: 'teaching_id',
          select: 'section semester subject_id',
          populate: { path: 'subject_id', select: 'name code' }
        }
      })
      .sort({ marked_at: -1 });

    // Filter out records with orphaned sessions or teachings
    const history = historyRaw.filter(record =>
      record.session_id != null && record.session_id.teaching_id != null
    );

    // Transform for frontend compatibility
    const formattedHistory = history.map(record => ({
      _id: record._id,
      marked_at: record.marked_at,
      session: record.session_id ? {
        _id: record.session_id._id,
        subject: record.session_id.teaching_id?.subject_id?.name || 'Unknown',
        subject_code: record.session_id.teaching_id?.subject_id?.code || 'N/A',
        section: record.session_id.teaching_id?.section,
        class_start_time: record.session_id.start_time
      } : null
    }));

    res.json(formattedHistory);

  } catch (error) {
    console.error('Get history error:', error);
    res.status(500).json({ message: 'Error fetching history' });
  }
};

/**
 * @desc    Get session details (for teacher)
 * @route   GET /api/attendance/session/:sessionId
 * @access  Teacher only
 */
const getSessionDetails = async (req, res) => {
  try {
    const { sessionId } = req.params;

    // Fetch session without secret_key
    const session = await SessionNew.findById(sessionId)
      .select('-secret_key')
      .populate({
        path: 'teaching_id',
        populate: [
          { path: 'subject_id', select: 'name code' },
          { path: 'faculty_id', select: 'name email' }
        ]
      });

    if (!session) {
      return res.status(404).json({ message: 'Session not found' });
    }

    // Verify teacher owns this session
    if (session.teaching_id?.faculty_id?._id.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'Not authorized to view this session' });
    }

    // Get attendees
    const attendees = await AttendanceNew.find({ session_id: sessionId })
      .select('student_name student_usn marked_at');

    // Format response for frontend compatibility
    res.json({
      session: {
        _id: session._id,
        subject: session.teaching_id?.subject_id?.name || 'Unknown',
        subject_code: session.teaching_id?.subject_id?.code || 'N/A',
        section: session.teaching_id?.section,
        semester: session.teaching_id?.semester,
        class_start_time: session.start_time,
        class_end_time: session.end_time,
        status: session.status,
        created_at: session.created_at
      },
      attendees: attendees.map(a => ({
        student_name: a.student_name,
        usn: a.student_usn,
        timestamp: a.marked_at
      }))
    });

  } catch (error) {
    console.error('Get session details error:', error);
    res.status(500).json({ message: 'Error fetching session details' });
  }
};

/**
 * @desc    Get student metrics (dashboard)
 * @route   GET /api/attendance/student-metrics
 * @access  Student only
 */
const getStudentMetrics = async (req, res) => {
  try {
    const student = req.user;

    // 1. Get all attendance records for this student
    const allAttendance = await AttendanceNew.find({ student_id: student._id });
    const attendedSessionIds = new Set(allAttendance.map(a => a.session_id.toString()));

    // 2. Get all sessions for courses the student is enrolled in
    // Find Teaching assignments matching student's section + semester
    const enrolledTeachings = await Teaching.find({
      section: student.section,
      semester: student.semester,
      is_active: true
    }).populate('subject_id', 'name code');

    const teachingIds = enrolledTeachings.map(t => t._id);

    // Get all sessions for enrolled teachings
    const allSessionsRaw = await SessionNew.find({
      teaching_id: { $in: teachingIds },
      status: { $ne: 'cancelled' }
    }).populate({
      path: 'teaching_id',
      populate: { path: 'subject_id', select: 'name code' }
    });

    // Filter out orphaned sessions (teaching_id could be null if Teaching was deleted)
    const allSessions = allSessionsRaw.filter(session => session.teaching_id != null);

    // 3. Aggregate by subject
    const subjectStats = {};

    allSessions.forEach(session => {
      const subjectName = session.teaching_id?.subject_id?.name || 'Unknown';
      const subjectCode = session.teaching_id?.subject_id?.code || 'N/A';
      const key = subjectCode;

      if (!subjectStats[key]) {
        subjectStats[key] = {
          total: 0,
          attended: 0,
          subject: subjectName,
          code: subjectCode
        };
      }

      subjectStats[key].total += 1;

      if (attendedSessionIds.has(session._id.toString())) {
        subjectStats[key].attended += 1;
      }
    });

    // 4. Format output for frontend
    const classes = Object.values(subjectStats).map((stat, index) => {
      const percent = stat.total === 0 ? 0 : Math.round((stat.attended / stat.total) * 100);
      return {
        classId: `subject-${index}`,
        name: stat.subject,
        code: stat.code,
        attended: stat.attended,
        total: stat.total,
        percent
      };
    });

    // 5. Calculate overall metrics
    const totalSessions = allSessions.length;
    const attendedSessions = allAttendance.length;
    const overallPercent = totalSessions === 0
      ? 0
      : Math.round((attendedSessions / totalSessions) * 100);

    res.json({
      totalSessions,
      attendedSessions,
      overallPercent,
      attendancePercentage: overallPercent, // Backward compatibility
      classes
    });

  } catch (error) {
    console.error('Get student metrics error:', error);
    res.status(500).json({ message: 'Error fetching metrics' });
  }
};

/**
 * @desc    Get teacher dashboard data
 * @route   GET /api/attendance/teacher-dashboard
 * @access  Teacher only
 */
const getTeacherDashboardData = async (req, res) => {
  try {
    const facultyId = req.user._id;

    // 1. Get all Teaching assignments for this faculty
    const teachings = await Teaching.find({
      faculty_id: facultyId,
      is_active: true
    }).populate('subject_id', 'name code');

    const teachingIds = teachings.map(t => t._id);

    // 2. Get all sessions for these teachings
    const sessionsRaw = await SessionNew.find({ teaching_id: { $in: teachingIds } })
      .populate({
        path: 'teaching_id',
        populate: { path: 'subject_id', select: 'name code' }
      })
      .sort({ start_time: -1 });

    // Filter out orphaned sessions (teaching_id could be null if Teaching was deleted)
    const sessions = sessionsRaw.filter(session => session.teaching_id != null);

    // 3. Calculate metrics
    const totalSessions = sessions.length;
    const now = new Date();

    const startOfDay = new Date(now);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(now);
    endOfDay.setHours(23, 59, 59, 999);

    const sessionsToday = sessions.filter(session => {
      const sessionDate = new Date(session.start_time);
      return sessionDate >= startOfDay && sessionDate <= endOfDay;
    }).length;

    // Update status for active check
    let activeSessions = 0;
    for (const session of sessions) {
      session.updateStatusByTime();
      if (session.status === 'active') {
        activeSessions++;
      }
    }

    // 4. Format recent sessions for frontend
    const recentSessions = sessions.slice(0, 5).map(s => ({
      _id: s._id,
      subject: s.teaching_id?.subject_id?.name || 'Unknown',
      subject_code: s.teaching_id?.subject_id?.code || 'N/A',
      section: s.teaching_id?.section,
      class_start_time: s.start_time,
      class_end_time: s.end_time,
      status: s.status,
      is_active: s.status === 'active'
    }));

    res.json({
      totalSessions,
      activeSessions,
      sessionsToday,
      recentSessions,
      teachings: teachings.map(t => ({
        _id: t._id,
        subject: t.subject_id?.name,
        subject_code: t.subject_id?.code,
        section: t.section,
        semester: t.semester
      }))
    });

  } catch (error) {
    console.error('Get teacher dashboard error:', error);
    res.status(500).json({ message: 'Error fetching teacher dashboard data' });
  }
};

/**
 * @desc    Generate new QR token for session
 * @route   POST /api/attendance/session/:sessionId/rotate-token
 * @access  Teacher only
 */
const rotateQRToken = async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { validity_ms = 60000 } = req.body;

    // Validate session exists
    const session = await SessionNew.findById(sessionId).populate({
      path: 'teaching_id',
      select: 'faculty_id'
    });

    if (!session) {
      return res.status(404).json({ message: 'Session not found' });
    }

    // Verify teacher owns this session
    if (session.teaching_id?.faculty_id?.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'Not authorized to manage this session' });
    }

    // Verify session is active
    session.updateStatusByTime();
    if (session.status !== 'active') {
      return res.status(400).json({ message: 'Can only rotate tokens for active sessions' });
    }

    // Generate new token
    const qrToken = await QRToken.generateForSession(session._id, validity_ms);

    await AuditLog.log({
      action: 'QR_TOKEN_GENERATE',
      actor_type: 'faculty',
      actor_id: req.user._id,
      target_type: 'session',
      target_id: session._id,
      metadata: { validity_ms }
    });

    res.json({
      token: qrToken.token,
      expires_at: qrToken.expires_at,
      session_id: session._id
    });

  } catch (error) {
    console.error('Rotate token error:', error);
    res.status(500).json({ message: 'Error generating new token' });
  }
};

module.exports = {
  createSession,
  markAttendance,
  getStudentHistory,
  getSessionDetails,
  getStudentMetrics,
  getTeacherDashboardData,
  rotateQRToken
};
